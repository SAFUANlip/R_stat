noisycurve <- read.table("noisycurvebis.txt",header=T)
head(noisycurve)
dim(noisycurve)
Xobs0 <- noisycurve$X0
abscissa <- noisycurve$Abscissa
NT <- length(abscissa) # number of locations of observations
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
# Upload true data (without noise)
# X0 contains the values of the true curve
# X1 contains the values of the true first derivative
# X2 contains the values of the true second derivative
truecurve <- read.table("truecurve.txt",header=T)
head(truecurve)
points(abscissa,truecurve$X0vera,type="l", col = "orange", lwd = 2)
# compute the central finite differences (look loke it how we estamete derivatives)
rappincX1 <- (Xobs0[3:NT]-Xobs0[1:(NT-2)])/(abscissa[3:NT]-abscissa[1:(NT-2)])
rappincX2 <- ((Xobs0[3:NT]-Xobs0[2:(NT-1)])/(abscissa[3:NT]-abscissa[2:(NT-1)])-(Xobs0[2:(NT-1)]-Xobs0[1:(NT-2)])/(abscissa[2:(NT-1)]-abscissa[1:(NT-2)]))*2/(abscissa[3:(NT)]-abscissa[1:(NT-2)])
par(mfrow=c(1,3))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
par(mfrow=c(1,3))
plot(abscissa,Xobs0,xlab="t",ylab="observed data",main = "function")
points(truecurve$Abscissa,truecurve$X0vera,type='l',col="orange",lwd=3)
legend("topleft", legend = c("noisy data","true curve"), col = c("black", "orange"), lwd = c(1,2))
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l",main = "1st derivative")
points(truecurve$Abscissa,truecurve$X1vera,type='l',col="orange",lwd=3)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l",main = "2nd derivative")
points(truecurve$Abscissa,truecurve$X2vera,type='l',col="orange",lwd=3)
dev.off()
# Load package fda
library(fda)
# Set parameters
# so m = 1 => y =constant (degree m - 1), m = 2 (degree = 2-1, y=kx+b (polynomial of degree 1))
m <- 1           # spline order  # should be chosen from the nature of nature =>
# m−2 order of their derivatives!
degree <- m-1    # spline degree (degree of polynomilas, which will be used in basis functions)
nbasis <- 10 # number of internal
# Create the basis
help(create.bspline.basis)
basis <- create.bspline.basis(rangeval=c(0,1), nbasis=nbasis, norder=m)
# If breaks are not provided, equally spaced knots are created
names(basis)
basis$basisvalues
plot(basis)
# Сетка
x <- seq(0, 1, length.out = 200)
y_all <- eval.basis(x, basis)
# Цвета — используем готовую палитру R
colors <- rainbow(nbasis)
# Инициализация графика (пустой)
plot(x, y_all[,1], type='n', ylim=range(y_all),
xlab="x", ylab="Basis Function Value",
main="B-spline Basis Functions")
# Цикл по всем базисным функциям
for (i in 1:nbasis) {
lines(x, y_all[,i], col=colors[i], lwd=2)
}
# Добавим внутренние узлы
abline(v = basis$params, col = "gray60", lty = 3)
# Легенда
legend("topright", legend=paste("B", 1:nbasis, sep=""),
col=colors, lwd=2, cex=0.8)
help(lsfit)
# Evaluate the basis on the grid of abscissa
basismat <- eval.basis(abscissa, basis)
dim(basismat) # number of data x number of basis
head(basismat)
est_coef = lsfit(basismat, Xobs0, intercept=FALSE)$coef
est_coef
Xsp0 <- basismat %*% est_coef
par(mfrow=c(1,1))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsp0 ,type="l",col="blue",lwd=2)
abline(v=basis$params)
# to obtain the first derivative (argument Lfdobj=1)
basismat1<- eval.basis(abscissa, basis, Lfdobj=1)
head(basismat1)
Xsp1 <- basismat1 %*% est_coef
# to obtain the second derivative (argument Lfdobj=2)
basismat2<- eval.basis(abscissa, basis, Lfdobj=2)
Xsp2 <- basismat2 %*% est_coef
par(mfrow=c(1,3))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,truecurve$X0vera ,type="l",col="orange",lwd=3)
points(abscissa,Xsp0 ,type="l",col="blue",lwd=2)
legend("topleft", legend = c("noisy data","true curve","estimated curve"), col = c("black", "orange","blue"), lwd = c(1,3,2))
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
points(truecurve$Abscissa,truecurve$X1vera,type='l',col="orange",lwd=3)
points(abscissa,Xsp1 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
points(truecurve$Abscissa,truecurve$X2vera,type='l',col="orange",lwd=3)
points(abscissa,Xsp2 ,type="l",col="blue",lwd=2)
dev.off()
help(smooth.basis)
Xsp <- smooth.basis(argvals=abscissa, y=Xobs0, fdParobj=basis)
Xsp0bis <- eval.fd(abscissa, Xsp$fd) #  the curve smoothing the data
Xsp1bis <- eval.fd(abscissa, Xsp$fd, Lfd=1) # first derivative
Xsp2bis <- eval.fd(abscissa, Xsp$fd, Lfd=2) # second derivative
df <- Xsp$df   #  the degrees of freedom in the smoothing curve
df             #  for regression splines the df are the number of basis
nbasis <- 7
basisbis <- create.bspline.basis(c(0,1), nbasis, m)
par(mfrow=c(1,1))
plot(basisbis)
basismatbis <- eval.basis(abscissa, basisbis)
Xsp0bis <- basismatbis %*% lsfit(basismatbis, Xobs0, intercept=FALSE)$coef
basismat1bis <- eval.basis(abscissa, basisbis,Lfdobj=1)
Xsp1bis <- basismat1bis %*% lsfit(basismatbis, Xobs0, intercept=FALSE)$coef
basismat2bis <- eval.basis(abscissa, basisbis,Lfdobj=2)
Xsp2bis <- basismat2bis %*% lsfit(basismatbis, Xobs0, intercept=FALSE)$coef
par(mfrow=c(1,1))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsp0bis ,type="l",col="green",lwd=2)
abline(v=basisbis$params,lty=2)
par(mfrow=c(1,3))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsp0bis ,type="l",col="green",lwd=2)
points(abscissa,Xsp0bis ,type="l",col="green",lwd=2)
points(abscissa,Xsp0 ,type="l",col="blue",lwd=2)
legend("topleft", legend = c("noisy data","estimate df = 7","estimate df = 9"), col = c("black", "green","blue"), lwd = c(1,2,2))
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
points(abscissa,Xsp1bis ,type="l",col="green",lwd=2)
points(abscissa,Xsp1 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
# Upload noisy data
noisycurve <- read.table("noisycurvebis.txt",header=T)
head(noisycurve)
dim(noisycurve)
Xobs0 <- noisycurve$X0
abscissa <- noisycurve$Abscissa
NT <- length(abscissa) # number of locations of observations
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
# Upload true data (without noise)
# X0 contains the values of the true curve
# X1 contains the values of the true first derivative
# X2 contains the values of the true second derivative
truecurve <- read.table("truecurve.txt",header=T)
head(truecurve)
points(abscissa,truecurve$X0vera,type="l", col = "orange", lwd = 2)
# compute the central finite differences (look loke it how we estamete derivatives)
rappincX1 <- (Xobs0[3:NT]-Xobs0[1:(NT-2)])/(abscissa[3:NT]-abscissa[1:(NT-2)])
rappincX2 <- ((Xobs0[3:NT]-Xobs0[2:(NT-1)])/(abscissa[3:NT]-abscissa[2:(NT-1)])-(Xobs0[2:(NT-1)]-Xobs0[1:(NT-2)])/(abscissa[2:(NT-1)]-abscissa[1:(NT-2)]))*2/(abscissa[3:(NT)]-abscissa[1:(NT-2)])
par(mfrow=c(1,3))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
par(mfrow=c(1,3))
plot(abscissa,Xobs0,xlab="t",ylab="observed data",main = "function")
points(truecurve$Abscissa,truecurve$X0vera,type='l',col="orange",lwd=3)
legend("topleft", legend = c("noisy data","true curve"), col = c("black", "orange"), lwd = c(1,2))
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l",main = "1st derivative")
points(truecurve$Abscissa,truecurve$X1vera,type='l',col="orange",lwd=3)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l",main = "2nd derivative")
points(truecurve$Abscissa,truecurve$X2vera,type='l',col="orange",lwd=3)
dev.off()
# Load package fda
library(fda)
# Set parameters
# so m = 1 => y =constant (degree m - 1), m = 2 (degree = 2-1, y=kx+b (polynomial of degree 1))
m <- 6           # spline order  # should be chosen from the nature of nature =>
# m−2 order of their derivatives!
degree <- m-1    # spline degree (degree of polynomilas, which will be used in basis functions)
nbasis <- 10 # number of internal
# Create the basis
help(create.bspline.basis)
basis <- create.bspline.basis(rangeval=c(0,1), nbasis=nbasis, norder=m)
# If breaks are not provided, equally spaced knots are created
names(basis)
basis$basisvalues
plot(basis)
# Сетка
x <- seq(0, 1, length.out = 200)
y_all <- eval.basis(x, basis)
# Цвета — используем готовую палитру R
colors <- rainbow(nbasis)
# Инициализация графика (пустой)
plot(x, y_all[,1], type='n', ylim=range(y_all),
xlab="x", ylab="Basis Function Value",
main="B-spline Basis Functions")
# Цикл по всем базисным функциям
for (i in 1:nbasis) {
lines(x, y_all[,i], col=colors[i], lwd=2)
}
# Добавим внутренние узлы
abline(v = basis$params, col = "gray60", lty = 3)
# Легенда
legend("topright", legend=paste("B", 1:nbasis, sep=""),
col=colors, lwd=2, cex=0.8)
help(lsfit)
# Evaluate the basis on the grid of abscissa
basismat <- eval.basis(abscissa, basis)
dim(basismat) # number of data x number of basis
head(basismat)
est_coef = lsfit(basismat, Xobs0, intercept=FALSE)$coef
est_coef
Xsp0 <- basismat %*% est_coef
par(mfrow=c(1,1))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsp0 ,type="l",col="blue",lwd=2)
abline(v=basis$params)
# to obtain the first derivative (argument Lfdobj=1)
basismat1<- eval.basis(abscissa, basis, Lfdobj=1)
head(basismat1)
Xsp1 <- basismat1 %*% est_coef
# to obtain the second derivative (argument Lfdobj=2)
basismat2<- eval.basis(abscissa, basis, Lfdobj=2)
Xsp2 <- basismat2 %*% est_coef
par(mfrow=c(1,3))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,truecurve$X0vera ,type="l",col="orange",lwd=3)
points(abscissa,Xsp0 ,type="l",col="blue",lwd=2)
legend("topleft", legend = c("noisy data","true curve","estimated curve"), col = c("black", "orange","blue"), lwd = c(1,3,2))
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
points(truecurve$Abscissa,truecurve$X1vera,type='l',col="orange",lwd=3)
points(abscissa,Xsp1 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
points(truecurve$Abscissa,truecurve$X2vera,type='l',col="orange",lwd=3)
points(abscissa,Xsp2 ,type="l",col="blue",lwd=2)
dev.off()
help(smooth.basis)
Xsp <- smooth.basis(argvals=abscissa, y=Xobs0, fdParobj=basis)
Xsp0bis <- eval.fd(abscissa, Xsp$fd) #  the curve smoothing the data
Xsp1bis <- eval.fd(abscissa, Xsp$fd, Lfd=1) # first derivative
Xsp2bis <- eval.fd(abscissa, Xsp$fd, Lfd=2) # second derivative
df <- Xsp$df   #  the degrees of freedom in the smoothing curve
df             #  for regression splines the df are the number of basis
nbasis <- 7
basisbis <- create.bspline.basis(c(0,1), nbasis, m)
par(mfrow=c(1,1))
plot(basisbis)
basismatbis <- eval.basis(abscissa, basisbis)
Xsp0bis <- basismatbis %*% lsfit(basismatbis, Xobs0, intercept=FALSE)$coef
basismat1bis <- eval.basis(abscissa, basisbis,Lfdobj=1)
Xsp1bis <- basismat1bis %*% lsfit(basismatbis, Xobs0, intercept=FALSE)$coef
basismat2bis <- eval.basis(abscissa, basisbis,Lfdobj=2)
Xsp2bis <- basismat2bis %*% lsfit(basismatbis, Xobs0, intercept=FALSE)$coef
par(mfrow=c(1,1))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsp0bis ,type="l",col="green",lwd=2)
abline(v=basisbis$params,lty=2)
par(mfrow=c(1,3))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsp0bis ,type="l",col="green",lwd=2)
points(abscissa,Xsp0 ,type="l",col="blue",lwd=2)
legend("topleft", legend = c("noisy data","estimate df = 7","estimate df = 9"), col = c("black", "green","blue"), lwd = c(1,2,2))
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
points(abscissa,Xsp1bis ,type="l",col="green",lwd=2)
points(abscissa,Xsp1 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
points(abscissa,Xsp2bis ,type="l",col="green",lwd=2)
points(abscissa,Xsp2 ,type="l",col="blue",lwd=2)
nbasis <- 30
basister <- create.bspline.basis(c(0,1), nbasis, m)
par(mfrow=c(1,1))
plot(basister)
basismatter <- eval.basis(abscissa, basister)
Xsp0ter <- basismatter %*% lsfit(basismatter, Xobs0, intercept=FALSE)$coef
basismat1ter <- eval.basis(abscissa, basister,Lfdobj=1)
Xsp1ter <- basismat1ter %*% lsfit(basismatter, Xobs0, intercept=FALSE)$coef
basismat2ter <- eval.basis(abscissa, basister,Lfdobj=2)
Xsp2ter <- basismat2ter %*% lsfit(basismatter, Xobs0, intercept=FALSE)$coef
par(mfrow=c(1,1))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsp0ter ,type="l",col="red",lwd=2)
abline(v=basister$params,lty=2)
par(mfrow=c(1,3))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsp0ter ,type="l",col="red",lwd=2)
points(abscissa,Xsp0bis ,type="l",col="green",lwd=2)
points(abscissa,Xsp0 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
points(abscissa,Xsp1ter ,type="l",col="red",lwd=2)
points(abscissa,Xsp1bis ,type="l",col="green",lwd=2)
points(abscissa,Xsp1 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
points(abscissa,Xsp2ter ,type="l",col="red",lwd=2)
points(abscissa,Xsp2bis ,type="l",col="green",lwd=2)
points(abscissa,Xsp2 ,type="l",col="blue",lwd=2)
# generalized cross-validation
nbasis <- 6:30
gcv <- numeric(length(nbasis))
for (i in 1:length(nbasis)){
basis <- create.bspline.basis(c(0,1), nbasis[i], m)
gcv[i] <- smooth.basis(abscissa, Xobs0, basis)$gcv
}
par(mfrow=c(1,1))
plot(nbasis,gcv)
nbasis[which.min(gcv)]
abline(v = nbasis[which.min(gcv)], col = 2)
sigma <- 0.003 # True sigma. Estimated before as sigmahat
library(fda)
#### First dataset: canadian weather ####
# daily temperatures recorded in 35 weather stations of Canada
# (data are averages over 35 years - 1960 to 1994)
help(CanadianWeather)
data_W <- CanadianWeather$dailyAv[,,1]
head(data_W)
dim(data_W)
matplot(data_W,type='l',main='Canadian temperature',xlab='Day',ylab='Temperature')
View(data_W)
time <- 1:365
# Choice 1: we set a high dimensional basis (interpolating)
# Pros: no loss of information
# Cons: possible overfitting
basis.1 <- create.fourier.basis(rangeval=c(0,365),nbasis=365)
data_W.fd.1 <- Data2fd(y = data_W,argvals = time,basisobj = basis.1)
plot.fd(data_W.fd.1)
# Choice 2: reduced dimensionality (we set a low dimensional basis)
# Pros: the data are much smoother and the measurement error is filtered
# Cons: I could have lost important information
basis.2 <- create.fourier.basis(rangeval=c(0,365),nbasis=21)
data_W.fd.2 <- Data2fd(y = data_W,argvals = time,basisobj = basis.2)
plot.fd(data_W.fd.2)
# Choice 3: compromise between 1 and 2
basis.3 <- create.fourier.basis(rangeval=c(0,365),nbasis=73)
data_W.fd.3 <- Data2fd(y = data_W,argvals = time,basisobj = basis.3)
plot.fd(data_W.fd.3)
# Choice 2: reduced dimensionality (we set a low dimensional basis)
# Pros: the data are much smoother and the measurement error is filtered
# Cons: I could have lost important information
basis.2 <- create.fourier.basis(rangeval=c(0,365),nbasis=12) # more strong smoothing
data_W.fd.2 <- Data2fd(y = data_W,argvals = time,basisobj = basis.2)
plot.fd(data_W.fd.2)
# Choice 2: reduced dimensionality (we set a low dimensional basis)
# Pros: the data are much smoother and the measurement error is filtered
# Cons: I could have lost important information
basis.2 <- create.fourier.basis(rangeval=c(0,365),nbasis=21) # more strong smoothing
data_W.fd.2 <- Data2fd(y = data_W,argvals = time,basisobj = basis.2)
plot.fd(data_W.fd.2)
# Choice 3: compromise between 1 and 2
basis.3 <- create.fourier.basis(rangeval=c(0,365),nbasis=73)
data_W.fd.3 <- Data2fd(y = data_W,argvals = time,basisobj = basis.3)
plot.fd(data_W.fd.3)
# estimate of the mean and of the covariance kernel
library(fields)
x11(width=10)
#mean
plot.fd(data_W.fd.1)
lines(mean.fd(data_W.fd.1),lwd=3)
plot.fd(data_W.fd.2)
lines(mean.fd(data_W.fd.2),lwd=2)
plot.fd(data_W.fd.3)
lines(mean.fd(data_W.fd.3),lwd=2)
# covariance
eval.1 <- eval.fd(time,data_W.fd.1)
image.plot(time,time,(cov(t(eval.1))[1:365,]))
eval.2 <- eval.fd(time,data_W.fd.2)
image.plot(time,time,(cor(t(eval.2))[1:365,]))
eval.3 <- eval.fd(time,data_W.fd.3)
image.plot(time,time,(cov(t(eval.3))[1:365,]))
graphics.off()
##### FPCA #####
help(pca.fd)
x11(width=10)
par(mfrow=c(2,3))
#mean
plot.fd(data_W.fd.1)
lines(mean.fd(data_W.fd.1),lwd=3)
plot.fd(data_W.fd.2)
lines(mean.fd(data_W.fd.2),lwd=2)
plot.fd(data_W.fd.3)
lines(mean.fd(data_W.fd.3),lwd=2)
# covariance
eval.1 <- eval.fd(time,data_W.fd.1)
image.plot(time,time,(cov(t(eval.1))[1:365,]))
eval.2 <- eval.fd(time,data_W.fd.2)
image.plot(time,time,(cor(t(eval.2))[1:365,]))
eval.3 <- eval.fd(time,data_W.fd.3)
image.plot(time,time,(cov(t(eval.3))[1:365,]))
graphics.off()
##### FPCA #####
help(pca.fd)
# interpolated data (Choice 3)
plot.fd(data_W.fd.3,ylab='temperature')
pca_W.3 <- pca.fd(data_W.fd.3,nharm=5,centerfns=TRUE)
# scree plot
# pca.fd computes all the 365 eigenvalues, but only the first
# N-1=34 are non-null
plot(pca_W.3$values[1:35],xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.3$values)[1:35]/sum(pca_W.3$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
# first two FPCs
x11()
layout(cbind(1,2))
plot(pca_W.3$harmonics[1,],col=1,ylab='FPC1',ylim=c(-0.1,0.08))
abline(h=0,lty=2)
plot(pca_W.3$harmonics[2,],col=2,ylab='FPC2',ylim=c(-0.1,0.08))
# scree plot
# pca.fd computes all the 365 eigenvalues, but only the first
# N-1=34 are non-null
plot(pca_W.3$values[1:35],xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.3$values)[1:35]/sum(pca_W.3$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
# first two FPCs
x11()
layout(cbind(1,2))
plot(pca_W.3$harmonics[1,],col=1,ylab='FPC1',ylim=c(-0.1,0.08))
abline(h=0,lty=2)
plot(pca_W.3$harmonics[2,],col=2,ylab='FPC2',ylim=c(-0.1,0.08))
# plot of the FPCs as perturbation of the mean
media <- mean.fd(data_W.fd.3)
plot(media,lwd=2,ylim=c(-25,20),ylab='temperature',main='FPC1')
lines(media+pca_W.3$harmonics[1,]*sqrt(pca_W.3$values[1]), col=2)
lines(media-pca_W.3$harmonics[1,]*sqrt(pca_W.3$values[1]), col=3)
dim(data_W)
# plot of the FPCs as perturbation of the mean
media <- mean.fd(data_W.fd.3)
plot(media,lwd=2,ylim=c(-25,20),ylab='temperature',main='FPC1')
lines(media+pca_W.3$harmonics[1,]*sqrt(pca_W.3$values[1]), col=2)
lines(media-pca_W.3$harmonics[1,]*sqrt(pca_W.3$values[1]), col=3)
plot(media,lwd=2,ylim=c(-20,20),ylab='temperature',main='FPC2')
lines(media+pca_W.3$harmonics[2,]*sqrt(pca_W.3$values[2]), col=2)
lines(media-pca_W.3$harmonics[2,]*sqrt(pca_W.3$values[2]), col=3)
# Command of the library fda that automatically does these plots
par(mfrow=c(1,2))
plot(pca_W.3, nx=100, pointplot=TRUE, harm=c(1,2), expand=0, cycle=FALSE)
###
# smooth data (Choice 2)
plot.fd(data_W.fd.2)
pca_W.2 <- pca.fd(data_W.fd.2,nharm=5,centerfns=TRUE)
# scree plot
plot(pca_W.2$values,xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.2$values)/sum(pca_W.2$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
# first two FPCs
x11()
layout(cbind(1,2))
plot(pca_W.2$harmonics[1,],col=1,ylab='FPC1',ylim=c(-0.1,0.08))
abline(h=0,lty=2)
plot(pca_W.2$harmonics[2,],col=2,ylab='FPC2',ylim=c(-0.1,0.08))
# plot of the FPCs as perturbation of the mean
media <- mean.fd(data_W.fd.2)
plot(media,lwd=2,ylim=c(-25,20),ylab='temperature',main='PC1')
lines(media+pca_W.2$harmonics[1,]*sqrt(pca_W.2$values[1]), col=2)
lines(media-pca_W.2$harmonics[1,]*sqrt(pca_W.2$values[1]), col=3)
plot(media,lwd=2,ylim=c(-20,20),ylab='temperature',main='PC2')
lines(media+pca_W.2$harmonics[2,]*sqrt(pca_W.2$values[2]), col=2)
lines(media-pca_W.2$harmonics[2,]*sqrt(pca_W.2$values[2]), col=3)
graphics.off()
# scatter plot of the scores
par(mfrow=c(1,2))
plot(pca_W.3$scores[,1],pca_W.3$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
points(pca_W.3$scores[35,1],pca_W.3$scores[35,2],col=2, lwd=4)
plot(pca_W.3$scores[,1],pca_W.3$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2",xlim=c(-400,250))
# scatter plot of the scores
par(mfrow=c(1,2))
plot(pca_W.3$scores[,1],pca_W.3$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
points(pca_W.3$scores[35,1],pca_W.3$scores[35,2],col=2, lwd=4)
plot(pca_W.3$scores[,1],pca_W.3$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2",xlim=c(-400,250))
text(pca_W.3$scores[,1],pca_W.3$scores[,2],dimnames(data_W)[[2]], cex=1)
layout(1)
matplot(eval.3,type='l')
lines(eval.3[,35],lwd=4, col=2) #temperature profile for Resolute
coord <- CanadianWeather$coordinates
coord[,2] <- -coord[,2]
plot(coord[,2:1],col=0)
text(coord[,2:1],rownames(coord))
#### Second dataset: lip ####
# 51 measurements of the position of the lower lip every 7
# milliseconds for 20 repetitions of the syllable 'bob'.
help(lip)
data_L <- lip
time <- seq(0,350,by=7)
matplot(time,data_L,type='l',main='Lip data',ylab='Position',
xlab='Time (millisec.)')
basis <- create.fourier.basis(rangeval=c(0,350),nbasis=51)
data_L.fd <- Data2fd(data_L,time,basis)
plot.fd(data_L.fd, main="Fourier")
# Better to use a b-spline basis
basis <- create.bspline.basis(rangeval=c(0,350),nbasis=21)
data_L.fd <- Data2fd(y = data_L,argvals = time,basisobj = basis)
plot.fd(data_L.fd, main="B-splines")
layout(cbind(1,2))
plot.fd(data_L.fd,xaxs='i')
lines(mean.fd(data_L.fd),lwd=2)
eval <- eval.fd(time,data_L.fd)
x11()
image.plot(time, time, (cov(t(eval))[1:51,]))
plot.fd(data_L.fd)
pca_L <- pca.fd(data_L.fd,nharm=5,centerfns=TRUE)
# scree plot
plot(pca_L$values,xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_L$values)/sum(pca_L$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
# First three FPCs
x11()
layout(cbind(1,2,3))
plot(pca_L$harmonics[1,],col=1,ylab='FPC1',ylim=c(-0.09,0.11))
plot(pca_L$harmonics[2,],col=2,ylab='FPC2',ylim=c(-0.09,0.11))
plot(pca_L$harmonics[3,],col=3,ylab='FPC3',ylim=c(-0.09,0.11))
# plot of the principal components as perturbation of the mean
media <- mean.fd(data_L.fd)
plot(media,lwd=2,ylim=c(-10,12),main='FPC1')
lines(media+pca_L$harmonic[1,]*sqrt(pca_L$values[1]), col=2)
lines(media-pca_L$harmonic[1,]*sqrt(pca_L$values[1]), col=3)
plot(media,lwd=2,ylim=c(-10,12),main='FPC2')
lines(media+pca_L$harmonic[2,]*sqrt(pca_L$values[2]), col=2)
lines(media-pca_L$harmonic[2,]*sqrt(pca_L$values[2]), col=3)
plot(media,lwd=2,ylim=c(-10,12),main='FPC3')
lines(media+pca_L$harmonic[3,]*sqrt(pca_L$values[3]), col=2)
lines(media-pca_L$harmonic[3,]*sqrt(pca_L$values[3]), col=3)
# Command of the library fda that automatically does these plots
par(mfrow=c(1,3))
plot.pca.fd(pca_L, nx=100, pointplot=TRUE, harm=c(1,2,3), expand=0, cycle=FALSE)
# Scores
layout(cbind(1,2,3))
plot(pca_L$scores[,1],pca_L$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
points(pca_L$scores[12,1],pca_L$scores[12,2],col=2, lwd=4)
points(pca_L$scores[9,1],pca_L$scores[9,2],col=3, lwd=4)
plot(pca_L$scores[,1],pca_L$scores[,3],xlab="Scores FPC1",ylab="Scores FPC3",lwd=2)
points(pca_L$scores[12,1],pca_L$scores[12,3],col=2, lwd=4)
points(pca_L$scores[9,1],pca_L$scores[9,3],col=3, lwd=4)
plot(pca_L$scores[,2],pca_L$scores[,3],xlab="Scores FPC2",ylab="Scores FPC3",lwd=2)
