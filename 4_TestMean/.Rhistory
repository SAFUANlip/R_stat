IC.chimina <-
c(M[3] - sqrt(quantile_fisher * S[3, 3] / n),
M[3],
M[3] + sqrt(quantile_fisher * S[3, 3] / n))
IC.elettrina <-
c(M[4] - sqrt(quantile_fisher * S[4, 4] / n),
M[4],
M[4] + sqrt(quantile_fisher * S[4, 4] / n))
T2.sim <- rbind(IC.matina, IC.fisina, IC.chimina, IC.elettrina)
dimnames(T2.sim)[[2]] <- c('inf', 'center', 'sup')
T2.sim
plot(1:nrow(T2.sim), T2.sim[, "center"], ylim = range(T2.sim),
xaxt = "n", xlab = "Variables", ylab = "Value",
main = "Simultaneous Confidence Intervals",
pch = 16, col = "blue")
# Добавляем интервалы
for (i in 1:nrow(T2.sim)) {
segments(i, T2.sim[i, "inf"], i, T2.sim[i, "sup"], lwd = 2)
}
# Ось X с названиями переменных
axis(1, at = 1:nrow(T2.sim), labels = rownames(T2.sim))
# c)
# H0: delta1 = 2, delta2 = -1, delta3 = - delta4
# i.e.,
# H0: delta1 = 2, delta2 = -1, delta3 + delta4 = 0
p.c <- 3 # 3 delta => 3 features
diff_df
delta.c <- c(2, -1, 0)
C <- matrix(
c(1, 0, 0, 0,
0, 1, 0, 0,
0, 0, 1, 1),
3, 4, byrow=T)
S.inv.c <- solve(C%*%S.inv%*%t(C))
M.c <- C%*%M
T2.c <- n*t(M.c-delta.c)%*%(S.inv.c)%*%(M.c-delta.c)
T2.c < quantile_fisher
p_value.c <- 1-pf(T2.c*(n-p.c)/((n-1)*p.c), p.c, n-p.c)
p_value.c
before <- read.table('before.txt', header=T)
after <- read.table('after.txt', header=T)
### question a)
D <- after - before
# verify normality
mcshapiro.test(D)
before <- read.table('before.txt', header=T)
after <- read.table('after.txt', header=T)
### question a)
D <- after - before
# verify normality
mcshapiro.test(D)
# test
alpha <- 0.01
n <- dim(D)[1]
p <- dim(D)[2]
D.mean   <- sapply(D,mean)
D.cov    <- cov(D)
D.invcov <- solve(D.cov)
delta.0 <- c(0,0,0,0)
D.T2 <- n * (D.mean-delta.0) %*% D.invcov %*% (D.mean-delta.0)
cfr.fisher <- (p*(n-1)/(n-p))*qf(1-alpha,p,n-p)
D.T2 < cfr.fisher
# pvalue (not requested)
P <- 1-pf(D.T2 * (n-p)/(p*(n-1)), p, n-p)
P
# Simultaneous T2 intervals for the components
T2 <- cbind( "Inf"= D.mean-sqrt(cfr.fisher*diag(D.cov)/n) , D.mean, Sup=D.mean+sqrt(cfr.fisher*diag(D.cov)/n) )
T2
A <- rbind(c(1,0,0,0),c(0,1,0,0),c(0,0,1,1))
## Way 1: we build a new dataset
D.new <- data.frame(as.matrix(D) %*% t(A))
p.new <- dim(D.new)[2]
n <- dim(D.new)[1]
alpha <- 0.01
D.new.mean   <- sapply(D.new,mean)
D.new.cov    <-  cov(D.new)
D.new.invcov <- solve(D.new.cov)
delta.0 <- c(2,-1,0)
D.T2 <- n * (D.new.mean-delta.0) %*% D.new.invcov %*% (D.new.mean-delta.0)
D.T2
cfr.fisher.new <- (p.new*(n-1)/(n-p.new))*qf(1-alpha,p.new,n-p.new)
D.T2 < cfr.fisher.new
# pvalue (not requested)
P <- 1-pf(D.T2 * (n-p.new)/(p.new*(n-1)), p.new, n-p.new)
P
## Way 2 (totally analogous):
## We perform a test for
## H0: A%*%mu.D == delta.0 vs H1: A%*%mu.D != delta.0
A <- rbind(c(1,0,0,0),c(0,1,0,0),c(0,0,1,1))
delta.0 <- c(2,-1,0)
T2.A <- n * t(A %*% D.mean - delta.0) %*% solve(A %*% D.cov %*% t(A)) %*% (A %*% D.mean - delta.0)
T2.A
T2.A < cfr.fisher.new
pound <- read.table('pound.txt', header=T)
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
before <- read.table("before.txt")
after <- read.table("after.txt")
matplot(before, type='l')
matplot(after, type='l')
alpha <- 0.01
diff_df <- after - before
delta <- c(0,0,0,0)
mvn(diff_df) # each of variable Normal
n <- dim(diff_df)[1]
p <- dim(diff_df)[2]
quantile_fisher <- (n-1)*p/(n-p)*qf(1-alpha, p, n-p)
M <- sapply(diff_df, mean)
S <- cov(diff_df)
S.inv <- solve(S)
T2 <- n*t(M-delta)%*%S.inv%*%(M-delta)
T2 < quantile_fisher
p_value <- 1 - pf(T2*(n-p)/((n-1)*p), p, n-p)
p_value # can not reject H0 on level 0.01 then we can not say,
IC.matina <-
c(M[1] - sqrt(quantile_fisher * S[1, 1] / n),
M[1],
M[1] + sqrt(quantile_fisher * S[1, 1] / n))
IC.fisina <-
c(M[2] - sqrt(quantile_fisher * S[2, 2] / n),
M[2],
M[2] + sqrt(quantile_fisher * S[2, 2] / n))
IC.chimina <-
c(M[3] - sqrt(quantile_fisher * S[3, 3] / n),
M[3],
M[3] + sqrt(quantile_fisher * S[3, 3] / n))
IC.elettrina <-
c(M[4] - sqrt(quantile_fisher * S[4, 4] / n),
M[4],
M[4] + sqrt(quantile_fisher * S[4, 4] / n))
T2.sim <- rbind(IC.matina, IC.fisina, IC.chimina, IC.elettrina)
dimnames(T2.sim)[[2]] <- c('inf', 'center', 'sup')
T2.sim
plot(1:nrow(T2.sim), T2.sim[, "center"], ylim = range(T2.sim),
xaxt = "n", xlab = "Variables", ylab = "Value",
main = "Simultaneous Confidence Intervals",
pch = 16, col = "blue")
# Добавляем интервалы
for (i in 1:nrow(T2.sim)) {
segments(i, T2.sim[i, "inf"], i, T2.sim[i, "sup"], lwd = 2)
}
# Ось X с названиями переменных
axis(1, at = 1:nrow(T2.sim), labels = rownames(T2.sim))
# c)
# H0: delta1 = 2, delta2 = -1, delta3 = - delta4
# i.e.,
# H0: delta1 = 2, delta2 = -1, delta3 + delta4 = 0
p.c <- 3 # 3 delta => 3 features
diff_df
delta.c <- c(2, -1, 0)
C <- matrix(
c(1, 0, 0, 0,
0, 1, 0, 0,
0, 0, 1, 1),
3, 4, byrow=T)
S.inv.c <- solve(C%*%S.inv%*%t(C))
M.c <- C%*%M
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
T2.c <- n*t(M.c-delta.c)%*%(S.inv.c)%*%(M.c-delta.c)
T2.c < quantile_fisher.c
p_value.c <- 1-pf(T2.c*(n-p.c)/((n-1)*p.c), p.c, n-p.c)
p_value.c
before <- read.table('before.txt', header=T)
after <- read.table('after.txt', header=T)
### question a)
D <- after - before
# verify normality
mcshapiro.test(D)
# test
alpha <- 0.01
n <- dim(D)[1]
p <- dim(D)[2]
D.mean   <- sapply(D,mean)
D.cov    <- cov(D)
D.invcov <- solve(D.cov)
delta.0 <- c(0,0,0,0)
D.T2 <- n * (D.mean-delta.0) %*% D.invcov %*% (D.mean-delta.0)
cfr.fisher <- (p*(n-1)/(n-p))*qf(1-alpha,p,n-p)
D.T2 < cfr.fisher
D.T2
cfr.fisher
P
# pvalue (not requested)
P <- 1-pf(D.T2 * (n-p)/(p*(n-1)), p, n-p)
P
before <- read.table("before.txt")
after <- read.table("after.txt")
matplot(before, type='l')
matplot(after, type='l')
alpha <- 0.01
diff_df <- after - before
delta <- c(0,0,0,0)
mvn(diff_df) # each of variable Normal
n <- dim(diff_df)[1]
p <- dim(diff_df)[2]
quantile_fisher <- (n-1)*p/(n-p)*qf(1-alpha, p, n-p)
M <- sapply(diff_df, mean)
S <- cov(diff_df)
S.inv <- solve(S)
T2 <- n*t(M-delta)%*%S.inv%*%(M-delta)
T2 < quantile_fisher
T2
quantile_fisher
p_value <- 1 - pf(T2*(n-p)/((n-1)*p), p, n-p)
p_value # can not reject H0 on level 0.01 then we can not say,
p_value
# Simultaneous T2 intervals for the components
T2 <- cbind( "Inf"= D.mean-sqrt(cfr.fisher*diag(D.cov)/n) , D.mean, Sup=D.mean+sqrt(cfr.fisher*diag(D.cov)/n) )
T2
matplot(after, type='l')
matplot(after, type='l')
matplot(diff_df, type='l')
M
D.mean
T2
IC.matina <-
c(M[1] - sqrt(quantile_fisher * S[1, 1] / n),
M[1],
M[1] + sqrt(quantile_fisher * S[1, 1] / n))
IC.matina
IC.fisina <-
c(M[2] - sqrt(quantile_fisher * S[2, 2] / n),
M[2],
M[2] + sqrt(quantile_fisher * S[2, 2] / n))
IC.fisina
IC.chimina <-
c(M[3] - sqrt(quantile_fisher * S[3, 3] / n),
M[3],
M[3] + sqrt(quantile_fisher * S[3, 3] / n))
IC.chimina
IC.elettrina <-
c(M[4] - sqrt(quantile_fisher * S[4, 4] / n),
M[4],
M[4] + sqrt(quantile_fisher * S[4, 4] / n))
IC.elettrina
T2.sim <- rbind(IC.matina, IC.fisina, IC.chimina, IC.elettrina)
T2.sim
T2
dimnames(T2.sim)[[2]] <- c('inf', 'center', 'sup')
T2.sim
T2
plot(1:nrow(T2.sim), T2.sim[, "center"], ylim = range(T2.sim),
xaxt = "n", xlab = "Variables", ylab = "Value",
main = "Simultaneous Confidence Intervals",
pch = 16, col = "blue")
# Добавляем интервалы
for (i in 1:nrow(T2.sim)) {
segments(i, T2.sim[i, "inf"], i, T2.sim[i, "sup"], lwd = 2)
}
# Ось X с названиями переменных
axis(1, at = 1:nrow(T2.sim), labels = rownames(T2.sim))
T2
# c)
# H0: delta1 = 2, delta2 = -1, delta3 = - delta4
# i.e.,
# H0: delta1 = 2, delta2 = -1, delta3 + delta4 = 0
p.c <- 3 # 3 delta => 3 features
diff_df
delta.c <- c(2, -1, 0)
C <- matrix(
c(1, 0, 0, 0,
0, 1, 0, 0,
0, 0, 1, 1),
3, 4, byrow=T)
S.inv.c <- solve(C%*%S.inv%*%t(C))
M.c <- C%*%M
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
T2.c <- n*t(M.c-delta.c)%*%(S.inv.c)%*%(M.c-delta.c)
T2.c < quantile_fisher.c
p_value.c <- 1-pf(T2.c*(n-p.c)/((n-1)*p.c), p.c, n-p.c)
p_value.c
# H0: delta1 = 2, delta2 = -1, delta3 = - delta4
# i.e.,
# H0: delta1 = 2, delta2 = -1, delta3 + delta4 = 0
p.c <- 3 # 3 delta => 3 features
diff_df
delta.c <- c(2, -1, 0)
C <- matrix(
c(1, 0, 0, 0,
0, 1, 0, 0,
0, 0, 1, 1),
3, 4, byrow=T)
S.inv.c <- solve(C%*%S.inv%*%t(C))
M.c <- C%*%M.c
M.c <- C%*%M
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
T2.c <- n*t(M.c-delta.c)%*%(S.inv.c)%*%(M.c-delta.c)
T2.c < quantile_fisher.c
p_value.c <- 1-pf(T2.c*(n-p.c)/((n-1)*p.c), p.c, n-p.c)
p_value.c
alpha
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
quantile_fisher.c
cfr.fisher.new
cfr.fisher.new <- (p.new*(n-1)/(n-p.new))*qf(1-alpha,p.new,n-p.new)
A <- rbind(c(1,0,0,0),c(0,1,0,0),c(0,0,1,1))
## Way 1: we build a new dataset
D.new <- data.frame(as.matrix(D) %*% t(A))
p.new <- dim(D.new)[2]
n <- dim(D.new)[1]
alpha <- 0.01
D.new.mean   <- sapply(D.new,mean)
D.new.cov    <-  cov(D.new)
D.new.invcov <- solve(D.new.cov)
delta.0 <- c(2,-1,0)
D.T2 <- n * (D.new.mean-delta.0) %*% D.new.invcov %*% (D.new.mean-delta.0)
D.T2
cfr.fisher.new <- (p.new*(n-1)/(n-p.new))*qf(1-alpha,p.new,n-p.new)
cfr.fisher.new
quantile_fisher.c
M.c
A %*% D.mean
solve(A %*% D.cov %*% t(A))
S.inv.c
S.inv.c <- solve(C%*%S%*%t(C))
S.inv.c
M.c <- C%*%M
M.c
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
T2.c <- n*t(M.c-delta.c)%*%(S.inv.c)%*%(M.c-delta.c)
T2.c < quantile_fisher.c
p_value.c <- 1-pf(T2.c*(n-p.c)/((n-1)*p.c), p.c, n-p.c)
p_value.c
quantile_fisher.c
S.c <- (C%*%S%*%t(C))
cbind( "Inf"= M.c-sqrt(quantile_fisher.c*diag(S.c)/n) , M.c, Sup=M.c+sqrt(quantile_fisher.c*diag(S.c)/n) )
T2 < quantile_fisher
before <- read.table("before.txt")
after <- read.table("after.txt")
matplot(before, type='l')
matplot(after, type='l')
alpha <- 0.01
diff_df <- after - before
matplot(diff_df, type='l')
M
delta <- c(0,0,0,0)
mvn(diff_df) # each of variable Normal
n <- dim(diff_df)[1]
p <- dim(diff_df)[2]
quantile_fisher <- (n-1)*p/(n-p)*qf(1-alpha, p, n-p)
M <- sapply(diff_df, mean)
S <- cov(diff_df)
S.inv <- solve(S)
T2 <- n*t(M-delta)%*%S.inv%*%(M-delta)
T2 < quantile_fisher
T2
quantile_fisher
# For variance:
IC.var <- matrix(NA, nrow=p, ncol=3)
rownames(IC.var) <- colnames(exchange_increment)
colnames(IC.var) <- c("inf", "center", "sup")
exchange <- read.table("exchange.txt", header=TRUE)
dim(exchange)
incremetC <- matrix(0, 30, 2, byrow=T)
for (i in 1:30){
incremetC[i,1] = exchange[i+1,1] - exchange[i,1]
incremetC[i,2] = exchange[i+1,2] - exchange[i,2]
}
exchange_increment <- data.frame(
dollar = incremetC[,1],
pound  = incremetC[,2]
)
mvn(exchange_increment) # doesn't seem MVN
n <- dim(exchange)[1]
p <- dim(exchange)[2]
alpha <- 0.05
M <- sapply(exchange_increment, mean) # sample mean
M
S <- cov(exchange_increment) # covariance matrix
S
S.inv <- solve(S)
delta.0 = c(0,0)
T2 <- n*t(M-delta.0)%*%S.inv%*%(M-delta.0)
quntile_fisher <- (n-1)*p/(n-p)*qf(1-alpha, p, n-p)
T2 < quntile_fisher # so we can reject H0, of equal deltas (so we have different means)
# p-value (So we can reject H0 of equal inrements)
1 - pf(T2*(n-p)/((n-1)*p), p, n-p)
matplot(t(exchange_increment), type='l', lty = 1)
### Bonferroni intervals
k <- p  # Number of Bonferroni intervals
cfr.t <- qt(1-alpha/(2*k), n-1) # Student quantile
# Bonferroni confidence intervals in the direction of DBOD and DSS
IC.BF.dollar <- c(M[1] - cfr.t*sqrt(S[1,1]/n),
M[1],
M[1] + cfr.t*sqrt(S[1,1]/n))
IC.BF.pound  <- c(M[2] - cfr.t*sqrt(S[2,2]/n),
M[2],
M[2] + cfr.t*sqrt(S[2,2]/n))
# Bonferroni region defined by the cartesian product of the Bf intervals
Bf <- rbind(IC.BF.dollar, IC.BF.pound)
dimnames(Bf)[[2]] <- c('inf','center','sup')
Bf
# For variance:
IC.var <- matrix(NA, nrow=p, ncol=3)
rownames(IC.var) <- colnames(exchange_increment)
colnames(IC.var) <- c("inf", "center", "sup")
for (j in 1:p) {
var_j <- S[j,j]
IC.var[j, ] <- c(
(n - 1) * var_j / qchisq(1 - alpha / (2 * k), df = n - 1),
var_j,
(n - 1) * var_j / qchisq(alpha / (2 * k), df = n - 1)
)
}
IC.var
M
M   <- mobile[,2] - 3*mobile[,1]
mobile <- read.table('mobile.txt', header=T)
plot(mobile, asp=1)
dev.off()
mcshapiro.test(mobile)
### question a)
n <- dim(mobile)[1]
p <- dim(mobile)[2]
x.mean   <- sapply(mobile,mean)
x.cov    <- cov(mobile)
alpha <- 0.10
cfr.fisher <- (p*(n-1)/(n-p))*qf(1-alpha,p,n-p)
A <- rbind(c(1,0), c(0,1), c(-1,1))
ICT2 <- cbind(A %*% x.mean - sqrt(diag(A %*% x.cov %*% t(A))/n * cfr.fisher),
A %*% x.mean,
A %*% x.mean + sqrt(diag(A %*% x.cov %*% t(A))/n * cfr.fisher))
ICT2
plot(mobile, asp=1)
ellipse(x.mean, x.cov/n, cfr.fisher, add=T)
M   <- mobile[,2] - 3*mobile[,1]
t.M <- abs(mean(M))/sqrt(var(M)/n)
M
t.M <- abs(mean(M))/sqrt(var(M)/n)
t.M
P   <- (1 - pt(t.M, n-1))*2
P
t.test(M)
P
t.test(M)
t.test(mobile[,2], 3*mobile[,1])
t.test(M)
# The p-value isn't very high (but I don't reject for levels 5%, 1%).
plot(D)
effluent <- read.table('effluent.txt', header = T)
effluent
pairs(effluent, pch=19, main='Dataset effluent')
# we compute the sample of differences
D <- data.frame(
DBOD = effluent$BOD_Lab1 - effluent$BOD_Lab2,
DSS  = effluent$SS_Lab1 - effluent$SS_Lab2
)
D
# Scatter plot of the dataset of differences with the four quadrants
plot(D, asp=1, pch=19, main='Dataset of Differences')
abline(h=0, v=0, col='grey35')
points(0,0, pch=19, col='grey35')
# Test the Gaussian assumption (on D!)
result <- mvn(data = D)
result$multivariateNormality
# The p-value isn't very high (but I don't reject for levels 5%, 1%).
plot(D)
n <- dim(D)[1]
p <- dim(D)[2]
D.mean   <- sapply(D, mean)
D.cov    <- cov(D)
D.mean
D
alpha   <- .05
delta.0 <- c(0, 0)
D.T2 <- n * (D.mean - delta.0) %*% D.invcov %*% (D.mean - delta.0)
D.T2
alpha   <- .05
delta.0 <- c(0, 0)
D.T2 <- n * (D.mean - delta.0) %*% D.invcov %*% (D.mean - delta.0)
D.T2
effluent <- read.table('effluent.txt', header = T)
effluent
pairs(effluent, pch=19, main='Dataset effluent')
# we compute the sample of differences
D <- data.frame(
DBOD = effluent$BOD_Lab1 - effluent$BOD_Lab2,
DSS  = effluent$SS_Lab1 - effluent$SS_Lab2
)
D
# Scatter plot of the dataset of differences with the four quadrants
plot(D, asp=1, pch=19, main='Dataset of Differences')
abline(h=0, v=0, col='grey35')
points(0,0, pch=19, col='grey35')
# Test the Gaussian assumption (on D!)
result <- mvn(data = D)
result$multivariateNormality
# The p-value isn't very high (but I don't reject for levels 5%, 1%).
plot(D)
n <- dim(D)[1]
p <- dim(D)[2]
D.mean   <- sapply(D, mean)
D.cov    <- cov(D)
D.invcov <- solve(D.cov)
alpha   <- .05
delta.0 <- c(0, 0)
D.T2 <- n * (D.mean - delta.0) %*% D.invcov %*% (D.mean - delta.0)
D.T2
cfr.fisher <- ((n - 1) * p / (n - p)) * qf(1 - alpha, p, n - p)
cfr.fisher
D.T2 < cfr.fisher # FALSE: we reject H0 at level 5%
pontevedra <- read.table('pontevedra.txt', header = T)
acoruna <- read.table('acoruna.txt', header = T)
View(acoruna)
mobile <- read.table("mobile.txt", header = TRUE)
matplot(mobile)
alpha <- 0.1
shapiro.test(mobile$Nokia5800)
shapiro.test(mobile$iphone)
n <- dim(mobile)[1]
p <- dim(mobile)[2]
p
View(mobile)
