## H0: A%*%mu.D == delta.0 vs H1: A%*%mu.D != delta.0
A <- rbind(c(1,0,0,0),c(0,1,0,0),c(0,0,1,1))
delta.0 <- c(2,-1,0)
T2.A <- n * t(A %*% D.mean - delta.0) %*% solve(A %*% D.cov %*% t(A)) %*% (A %*% D.mean - delta.0)
T2.A
T2.A < cfr.fisher.new
pound <- read.table('pound.txt', header=T)
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
before <- read.table("before.txt")
after <- read.table("after.txt")
matplot(before, type='l')
matplot(after, type='l')
alpha <- 0.01
diff_df <- after - before
delta <- c(0,0,0,0)
mvn(diff_df) # each of variable Normal
n <- dim(diff_df)[1]
p <- dim(diff_df)[2]
quantile_fisher <- (n-1)*p/(n-p)*qf(1-alpha, p, n-p)
M <- sapply(diff_df, mean)
S <- cov(diff_df)
S.inv <- solve(S)
T2 <- n*t(M-delta)%*%S.inv%*%(M-delta)
T2 < quantile_fisher
p_value <- 1 - pf(T2*(n-p)/((n-1)*p), p, n-p)
p_value # can not reject H0 on level 0.01 then we can not say,
IC.matina <-
c(M[1] - sqrt(quantile_fisher * S[1, 1] / n),
M[1],
M[1] + sqrt(quantile_fisher * S[1, 1] / n))
IC.fisina <-
c(M[2] - sqrt(quantile_fisher * S[2, 2] / n),
M[2],
M[2] + sqrt(quantile_fisher * S[2, 2] / n))
IC.chimina <-
c(M[3] - sqrt(quantile_fisher * S[3, 3] / n),
M[3],
M[3] + sqrt(quantile_fisher * S[3, 3] / n))
IC.elettrina <-
c(M[4] - sqrt(quantile_fisher * S[4, 4] / n),
M[4],
M[4] + sqrt(quantile_fisher * S[4, 4] / n))
T2.sim <- rbind(IC.matina, IC.fisina, IC.chimina, IC.elettrina)
dimnames(T2.sim)[[2]] <- c('inf', 'center', 'sup')
T2.sim
plot(1:nrow(T2.sim), T2.sim[, "center"], ylim = range(T2.sim),
xaxt = "n", xlab = "Variables", ylab = "Value",
main = "Simultaneous Confidence Intervals",
pch = 16, col = "blue")
# Добавляем интервалы
for (i in 1:nrow(T2.sim)) {
segments(i, T2.sim[i, "inf"], i, T2.sim[i, "sup"], lwd = 2)
}
# Ось X с названиями переменных
axis(1, at = 1:nrow(T2.sim), labels = rownames(T2.sim))
# c)
# H0: delta1 = 2, delta2 = -1, delta3 = - delta4
# i.e.,
# H0: delta1 = 2, delta2 = -1, delta3 + delta4 = 0
p.c <- 3 # 3 delta => 3 features
diff_df
delta.c <- c(2, -1, 0)
C <- matrix(
c(1, 0, 0, 0,
0, 1, 0, 0,
0, 0, 1, 1),
3, 4, byrow=T)
S.inv.c <- solve(C%*%S.inv%*%t(C))
M.c <- C%*%M
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
T2.c <- n*t(M.c-delta.c)%*%(S.inv.c)%*%(M.c-delta.c)
T2.c < quantile_fisher.c
p_value.c <- 1-pf(T2.c*(n-p.c)/((n-1)*p.c), p.c, n-p.c)
p_value.c
before <- read.table('before.txt', header=T)
after <- read.table('after.txt', header=T)
### question a)
D <- after - before
# verify normality
mcshapiro.test(D)
# test
alpha <- 0.01
n <- dim(D)[1]
p <- dim(D)[2]
D.mean   <- sapply(D,mean)
D.cov    <- cov(D)
D.invcov <- solve(D.cov)
delta.0 <- c(0,0,0,0)
D.T2 <- n * (D.mean-delta.0) %*% D.invcov %*% (D.mean-delta.0)
cfr.fisher <- (p*(n-1)/(n-p))*qf(1-alpha,p,n-p)
D.T2 < cfr.fisher
D.T2
cfr.fisher
P
# pvalue (not requested)
P <- 1-pf(D.T2 * (n-p)/(p*(n-1)), p, n-p)
P
before <- read.table("before.txt")
after <- read.table("after.txt")
matplot(before, type='l')
matplot(after, type='l')
alpha <- 0.01
diff_df <- after - before
delta <- c(0,0,0,0)
mvn(diff_df) # each of variable Normal
n <- dim(diff_df)[1]
p <- dim(diff_df)[2]
quantile_fisher <- (n-1)*p/(n-p)*qf(1-alpha, p, n-p)
M <- sapply(diff_df, mean)
S <- cov(diff_df)
S.inv <- solve(S)
T2 <- n*t(M-delta)%*%S.inv%*%(M-delta)
T2 < quantile_fisher
T2
quantile_fisher
p_value <- 1 - pf(T2*(n-p)/((n-1)*p), p, n-p)
p_value # can not reject H0 on level 0.01 then we can not say,
p_value
# Simultaneous T2 intervals for the components
T2 <- cbind( "Inf"= D.mean-sqrt(cfr.fisher*diag(D.cov)/n) , D.mean, Sup=D.mean+sqrt(cfr.fisher*diag(D.cov)/n) )
T2
matplot(after, type='l')
matplot(after, type='l')
matplot(diff_df, type='l')
M
D.mean
T2
IC.matina <-
c(M[1] - sqrt(quantile_fisher * S[1, 1] / n),
M[1],
M[1] + sqrt(quantile_fisher * S[1, 1] / n))
IC.matina
IC.fisina <-
c(M[2] - sqrt(quantile_fisher * S[2, 2] / n),
M[2],
M[2] + sqrt(quantile_fisher * S[2, 2] / n))
IC.fisina
IC.chimina <-
c(M[3] - sqrt(quantile_fisher * S[3, 3] / n),
M[3],
M[3] + sqrt(quantile_fisher * S[3, 3] / n))
IC.chimina
IC.elettrina <-
c(M[4] - sqrt(quantile_fisher * S[4, 4] / n),
M[4],
M[4] + sqrt(quantile_fisher * S[4, 4] / n))
IC.elettrina
T2.sim <- rbind(IC.matina, IC.fisina, IC.chimina, IC.elettrina)
T2.sim
T2
dimnames(T2.sim)[[2]] <- c('inf', 'center', 'sup')
T2.sim
T2
plot(1:nrow(T2.sim), T2.sim[, "center"], ylim = range(T2.sim),
xaxt = "n", xlab = "Variables", ylab = "Value",
main = "Simultaneous Confidence Intervals",
pch = 16, col = "blue")
# Добавляем интервалы
for (i in 1:nrow(T2.sim)) {
segments(i, T2.sim[i, "inf"], i, T2.sim[i, "sup"], lwd = 2)
}
# Ось X с названиями переменных
axis(1, at = 1:nrow(T2.sim), labels = rownames(T2.sim))
T2
# c)
# H0: delta1 = 2, delta2 = -1, delta3 = - delta4
# i.e.,
# H0: delta1 = 2, delta2 = -1, delta3 + delta4 = 0
p.c <- 3 # 3 delta => 3 features
diff_df
delta.c <- c(2, -1, 0)
C <- matrix(
c(1, 0, 0, 0,
0, 1, 0, 0,
0, 0, 1, 1),
3, 4, byrow=T)
S.inv.c <- solve(C%*%S.inv%*%t(C))
M.c <- C%*%M
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
T2.c <- n*t(M.c-delta.c)%*%(S.inv.c)%*%(M.c-delta.c)
T2.c < quantile_fisher.c
p_value.c <- 1-pf(T2.c*(n-p.c)/((n-1)*p.c), p.c, n-p.c)
p_value.c
# H0: delta1 = 2, delta2 = -1, delta3 = - delta4
# i.e.,
# H0: delta1 = 2, delta2 = -1, delta3 + delta4 = 0
p.c <- 3 # 3 delta => 3 features
diff_df
delta.c <- c(2, -1, 0)
C <- matrix(
c(1, 0, 0, 0,
0, 1, 0, 0,
0, 0, 1, 1),
3, 4, byrow=T)
S.inv.c <- solve(C%*%S.inv%*%t(C))
M.c <- C%*%M.c
M.c <- C%*%M
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
T2.c <- n*t(M.c-delta.c)%*%(S.inv.c)%*%(M.c-delta.c)
T2.c < quantile_fisher.c
p_value.c <- 1-pf(T2.c*(n-p.c)/((n-1)*p.c), p.c, n-p.c)
p_value.c
alpha
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
quantile_fisher.c
cfr.fisher.new
cfr.fisher.new <- (p.new*(n-1)/(n-p.new))*qf(1-alpha,p.new,n-p.new)
A <- rbind(c(1,0,0,0),c(0,1,0,0),c(0,0,1,1))
## Way 1: we build a new dataset
D.new <- data.frame(as.matrix(D) %*% t(A))
p.new <- dim(D.new)[2]
n <- dim(D.new)[1]
alpha <- 0.01
D.new.mean   <- sapply(D.new,mean)
D.new.cov    <-  cov(D.new)
D.new.invcov <- solve(D.new.cov)
delta.0 <- c(2,-1,0)
D.T2 <- n * (D.new.mean-delta.0) %*% D.new.invcov %*% (D.new.mean-delta.0)
D.T2
cfr.fisher.new <- (p.new*(n-1)/(n-p.new))*qf(1-alpha,p.new,n-p.new)
cfr.fisher.new
quantile_fisher.c
M.c
A %*% D.mean
solve(A %*% D.cov %*% t(A))
S.inv.c
S.inv.c <- solve(C%*%S%*%t(C))
S.inv.c
M.c <- C%*%M
M.c
quantile_fisher.c <- (n-1)*p.c/(n-p.c)*qf(1-alpha, p.c, n-p.c)
T2.c <- n*t(M.c-delta.c)%*%(S.inv.c)%*%(M.c-delta.c)
T2.c < quantile_fisher.c
p_value.c <- 1-pf(T2.c*(n-p.c)/((n-1)*p.c), p.c, n-p.c)
p_value.c
quantile_fisher.c
S.c <- (C%*%S%*%t(C))
cbind( "Inf"= M.c-sqrt(quantile_fisher.c*diag(S.c)/n) , M.c, Sup=M.c+sqrt(quantile_fisher.c*diag(S.c)/n) )
T2 < quantile_fisher
before <- read.table("before.txt")
after <- read.table("after.txt")
matplot(before, type='l')
matplot(after, type='l')
alpha <- 0.01
diff_df <- after - before
matplot(diff_df, type='l')
M
delta <- c(0,0,0,0)
mvn(diff_df) # each of variable Normal
n <- dim(diff_df)[1]
p <- dim(diff_df)[2]
quantile_fisher <- (n-1)*p/(n-p)*qf(1-alpha, p, n-p)
M <- sapply(diff_df, mean)
S <- cov(diff_df)
S.inv <- solve(S)
T2 <- n*t(M-delta)%*%S.inv%*%(M-delta)
T2 < quantile_fisher
T2
quantile_fisher
# For variance:
IC.var <- matrix(NA, nrow=p, ncol=3)
rownames(IC.var) <- colnames(exchange_increment)
colnames(IC.var) <- c("inf", "center", "sup")
exchange <- read.table("exchange.txt", header=TRUE)
dim(exchange)
incremetC <- matrix(0, 30, 2, byrow=T)
for (i in 1:30){
incremetC[i,1] = exchange[i+1,1] - exchange[i,1]
incremetC[i,2] = exchange[i+1,2] - exchange[i,2]
}
exchange_increment <- data.frame(
dollar = incremetC[,1],
pound  = incremetC[,2]
)
mvn(exchange_increment) # doesn't seem MVN
n <- dim(exchange)[1]
p <- dim(exchange)[2]
alpha <- 0.05
M <- sapply(exchange_increment, mean) # sample mean
M
S <- cov(exchange_increment) # covariance matrix
S
S.inv <- solve(S)
delta.0 = c(0,0)
T2 <- n*t(M-delta.0)%*%S.inv%*%(M-delta.0)
quntile_fisher <- (n-1)*p/(n-p)*qf(1-alpha, p, n-p)
T2 < quntile_fisher # so we can reject H0, of equal deltas (so we have different means)
# p-value (So we can reject H0 of equal inrements)
1 - pf(T2*(n-p)/((n-1)*p), p, n-p)
matplot(t(exchange_increment), type='l', lty = 1)
### Bonferroni intervals
k <- p  # Number of Bonferroni intervals
cfr.t <- qt(1-alpha/(2*k), n-1) # Student quantile
# Bonferroni confidence intervals in the direction of DBOD and DSS
IC.BF.dollar <- c(M[1] - cfr.t*sqrt(S[1,1]/n),
M[1],
M[1] + cfr.t*sqrt(S[1,1]/n))
IC.BF.pound  <- c(M[2] - cfr.t*sqrt(S[2,2]/n),
M[2],
M[2] + cfr.t*sqrt(S[2,2]/n))
# Bonferroni region defined by the cartesian product of the Bf intervals
Bf <- rbind(IC.BF.dollar, IC.BF.pound)
dimnames(Bf)[[2]] <- c('inf','center','sup')
Bf
# For variance:
IC.var <- matrix(NA, nrow=p, ncol=3)
rownames(IC.var) <- colnames(exchange_increment)
colnames(IC.var) <- c("inf", "center", "sup")
for (j in 1:p) {
var_j <- S[j,j]
IC.var[j, ] <- c(
(n - 1) * var_j / qchisq(1 - alpha / (2 * k), df = n - 1),
var_j,
(n - 1) * var_j / qchisq(alpha / (2 * k), df = n - 1)
)
}
IC.var
M
M   <- mobile[,2] - 3*mobile[,1]
mobile <- read.table('mobile.txt', header=T)
plot(mobile, asp=1)
dev.off()
mcshapiro.test(mobile)
### question a)
n <- dim(mobile)[1]
p <- dim(mobile)[2]
x.mean   <- sapply(mobile,mean)
x.cov    <- cov(mobile)
alpha <- 0.10
cfr.fisher <- (p*(n-1)/(n-p))*qf(1-alpha,p,n-p)
A <- rbind(c(1,0), c(0,1), c(-1,1))
ICT2 <- cbind(A %*% x.mean - sqrt(diag(A %*% x.cov %*% t(A))/n * cfr.fisher),
A %*% x.mean,
A %*% x.mean + sqrt(diag(A %*% x.cov %*% t(A))/n * cfr.fisher))
ICT2
plot(mobile, asp=1)
ellipse(x.mean, x.cov/n, cfr.fisher, add=T)
M   <- mobile[,2] - 3*mobile[,1]
t.M <- abs(mean(M))/sqrt(var(M)/n)
M
t.M <- abs(mean(M))/sqrt(var(M)/n)
t.M
P   <- (1 - pt(t.M, n-1))*2
P
t.test(M)
P
t.test(M)
t.test(mobile[,2], 3*mobile[,1])
t.test(M)
# The p-value isn't very high (but I don't reject for levels 5%, 1%).
plot(D)
effluent <- read.table('effluent.txt', header = T)
effluent
pairs(effluent, pch=19, main='Dataset effluent')
# we compute the sample of differences
D <- data.frame(
DBOD = effluent$BOD_Lab1 - effluent$BOD_Lab2,
DSS  = effluent$SS_Lab1 - effluent$SS_Lab2
)
D
# Scatter plot of the dataset of differences with the four quadrants
plot(D, asp=1, pch=19, main='Dataset of Differences')
abline(h=0, v=0, col='grey35')
points(0,0, pch=19, col='grey35')
# Test the Gaussian assumption (on D!)
result <- mvn(data = D)
result$multivariateNormality
# The p-value isn't very high (but I don't reject for levels 5%, 1%).
plot(D)
n <- dim(D)[1]
p <- dim(D)[2]
D.mean   <- sapply(D, mean)
D.cov    <- cov(D)
D.mean
D
alpha   <- .05
delta.0 <- c(0, 0)
D.T2 <- n * (D.mean - delta.0) %*% D.invcov %*% (D.mean - delta.0)
D.T2
alpha   <- .05
delta.0 <- c(0, 0)
D.T2 <- n * (D.mean - delta.0) %*% D.invcov %*% (D.mean - delta.0)
D.T2
effluent <- read.table('effluent.txt', header = T)
effluent
pairs(effluent, pch=19, main='Dataset effluent')
# we compute the sample of differences
D <- data.frame(
DBOD = effluent$BOD_Lab1 - effluent$BOD_Lab2,
DSS  = effluent$SS_Lab1 - effluent$SS_Lab2
)
D
# Scatter plot of the dataset of differences with the four quadrants
plot(D, asp=1, pch=19, main='Dataset of Differences')
abline(h=0, v=0, col='grey35')
points(0,0, pch=19, col='grey35')
# Test the Gaussian assumption (on D!)
result <- mvn(data = D)
result$multivariateNormality
# The p-value isn't very high (but I don't reject for levels 5%, 1%).
plot(D)
n <- dim(D)[1]
p <- dim(D)[2]
D.mean   <- sapply(D, mean)
D.cov    <- cov(D)
D.invcov <- solve(D.cov)
alpha   <- .05
delta.0 <- c(0, 0)
D.T2 <- n * (D.mean - delta.0) %*% D.invcov %*% (D.mean - delta.0)
D.T2
cfr.fisher <- ((n - 1) * p / (n - p)) * qf(1 - alpha, p, n - p)
cfr.fisher
D.T2 < cfr.fisher # FALSE: we reject H0 at level 5%
pontevedra <- read.table('pontevedra.txt', header = T)
acoruna <- read.table('acoruna.txt', header = T)
View(acoruna)
mobile <- read.table("mobile.txt", header = TRUE)
matplot(mobile)
alpha <- 0.1
shapiro.test(mobile$Nokia5800)
shapiro.test(mobile$iphone)
n <- dim(mobile)[1]
p <- dim(mobile)[2]
p
View(mobile)
rates <- read.table(file='exchange.txt', header=T)
head(rates)
dim(rates)
x11()
matplot(rates, type='l', ylim=c(0,3), lwd = 2, xlab='days')
legend(1,3,legend=c('Dollar','Pound'),col=1:2,lwd=2,lty=1:2)
diffrates <- matrix(NA, 30, 2)
for(i in 1:30)
diffrates[i,] <- as.numeric(rates[i+1,] - rates[i,])
diffrates
mcshapiro.test(diffrates)
library(car)
mcshapiro.test(diffrates)
rates <- read.table(file='exchange.txt', header=T)
head(rates)
dim(rates)
x11()
matplot(rates, type='l', ylim=c(0,3), lwd = 2, xlab='days')
legend(1,3,legend=c('Dollar','Pound'),col=1:2,lwd=2,lty=1:2)
diffrates <- matrix(NA, 30, 2)
for(i in 1:30)
diffrates[i,] <- as.numeric(rates[i+1,] - rates[i,])
diffrates
# we first need to verify the Gaussian assumption
plot(diffrates, asp=1, pch=1)
mcshapiro.test(diffrates)
mu0      <- c(0, 0)
x.mean   <- colMeans(diffrates)
x.cov    <- cov(diffrates)
x.invcov <- solve(x.cov)
n <- 30
p <- 2
x.T2       <- n * (x.mean-mu0) %*% x.invcov %*% (x.mean-mu0)
Pb <- 1-pf(x.T2*(n-p)/(p*(n-1)), p, n-p)
Pb
# mean under H0 (blue)
points(mu0[1], mu0[2], col='blue', pch=16)
# sample mean (black)
points(x.mean[1], x.mean[2], col='black', pch=16)
# we represent the confidence region of level 95%: where does mu0 fall?
alpha <- .05
cfr.fisher <- (p*(n-1)/(n-p))*qf(1-alpha,p,n-p)
ellipse(center=x.mean, shape=x.cov/n, radius=sqrt(cfr.fisher), lwd=2)
# we build the data: two bivariate samples of resp. 3 and 4 obs
t1 <- matrix(c(3, 3, 1, 6, 2, 3), 2)
t1 <- data.frame(t(t1))
t2 <- matrix(c(2, 3, 5, 1, 3, 1, 2, 3), 2)
t2 <- data.frame(t(t2))
t1
t2
n1 <- dim(t1)[1] # n1 = 3
n2 <- dim(t2)[1] # n2 = 4
n1
n1 <- dim(t1)[1] # n1 = 3
n2 <- dim(t2)[1] # n2 = 4
p  <- dim(t1)[2] # p = 2 nuber of features
t1.mean <- sapply(t1, mean)
t2.mean <- sapply(t2, mean)
t1.cov  <-  cov(t1)
t2.cov  <-  cov(t2)
Sp      <- ((n1 - 1) * t1.cov + (n2 - 1) * t2.cov) / (n1 + n2 - 2) # poll covariance matrix
# (thumb -rule)
# We compare the matrices -> here, using rule of thumb:
# we don't reject equality of covariance matrices if s1_ii and s2_ii differ from
# less than a factor ~4 (see J-W p.291) (factor ~4 <=> less than 0.25)
# короче если sigma11 <= 4sigma22 то все нор, ситаем дальше (без объяснения)
list(S1 = t1.cov, S2 = t2.cov, Spooled = Sp)
alpha   <- .01
delta.0 <- c(0, 0)
Spinv   <- solve(Sp)
T2 <- n1 * n2 / (n1 + n2) * (t1.mean - t2.mean - delta.0) %*% Spinv %*% (t1.mean - t2.mean - delta.0)
cfr.fisher <- (p * (n1 + n2 - 2) / (n1 + n2 - 1 - p)) * qf(1 - alpha, p, n1 + n2 - 1 - p)
T2 < cfr.fisher # TRUE: no statistical evidence to reject H0 at level 1%
P <- 1 - pf(T2 / (p * (n1 + n2 - 2) / (n1 + n2 - 1 - p)), p, n1 + n2 - 1 - p)
P
# Simultaneous T2 intervals
IC.T2.X1 <- c(
t1.mean[1] - t2.mean[1] - sqrt(cfr.fisher * Sp[1, 1] * (1 / n1 + 1 / n2)),
t1.mean[1] - t2.mean[1] + sqrt(cfr.fisher * Sp[1, 1] * (1 / n1 + 1 / n2))
)
IC.T2.X2 <- c(
t1.mean[2] - t2.mean[2] - sqrt(cfr.fisher * Sp[2, 2] * (1 / n1 + 1 / n2)),
t1.mean[2] - t2.mean[2] + sqrt(cfr.fisher * Sp[2, 2] * (1 / n1 + 1 / n2))
)
IC.T2 <- rbind(IC.T2.X1, IC.T2.X2)
dimnames(IC.T2)[[2]] <- c('inf', 'sup')
IC.T2
