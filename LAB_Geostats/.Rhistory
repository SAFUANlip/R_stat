## Clear the workspace
rm(list=ls())
## Clear the workspace
rm(list=ls())
library(sp)           ## Data management
library(lattice)      ## Data management
library(geoR)         ## Geostatistics
library(gstat)        ## Geostatistics
install.packages("geoR")
install.packages("gstat")
## Set working directory
setwd("~/Documents/Politecnico/Didattica/2025 Applied Statistics/Geostatistics")
## Functions for graphics
v.f <- function(x, ...){100-cov.spatial(x, ...)}
v.f.est<-function(x,C0, ...){C0-cov.spatial(x, ...)}
data(meuse)
## Clear the workspace
rm(list=ls())
library(sp)           ## Data management
library(lattice)      ## Data management
library(geoR)         ## Geostatistics
library(gstat)        ## Geostatistics
## Set working directory
setwd("~/Documents/Politecnico/Didattica/2025 Applied Statistics/Geostatistics")
## Functions for graphics
v.f <- function(x, ...){100-cov.spatial(x, ...)}
v.f.est<-function(x,C0, ...){C0-cov.spatial(x, ...)}
data(meuse)
## Define the sample coordinates
coordinates(meuse) <- c('x','y')
# bubble plot(obj,zcol,...)
# key.space=location of the key
bubble(meuse,'zinc',do.log=TRUE,key.space='bottom')
dev.off()
# river meuse
data(meuse.riv)
meuse.lst <- list(Polygons(list(Polygon(meuse.riv)), "meuse.riv"))
meuse.sr <- SpatialPolygons(meuse.lst)
## Define the sample coordinates
coordinates(meuse) <- c('x','y')
## Functions for graphics
v.f <- function(x, ...){100-cov.spatial(x, ...)}
v.f.est<-function(x,C0, ...){C0-cov.spatial(x, ...)}
data(meuse)
## Define the sample coordinates
coordinates(meuse) <- c('x','y')
# bubble plot(obj,zcol,...)
# key.space=location of the key
bubble(meuse,'zinc',do.log=TRUE,key.space='bottom')
dev.off()
# river meuse
data(meuse.riv)
meuse.lst <- list(Polygons(list(Polygon(meuse.riv)), "meuse.riv"))
meuse.sr <- SpatialPolygons(meuse.lst)
# grid for prediction
data(meuse.grid)
is(meuse.grid)
coordinates(meuse.grid) <- c('x','y')
meuse.grid <- as(meuse.grid, 'SpatialPixelsDataFrame')
View(meuse)
head(meuse)
# bubble plot(obj,zcol,...)
# key.space=location of the key
bubble(meuse,'zinc',do.log=TRUE,key.space='bottom')
# river meuse
data(meuse.riv)
meuse.lst <- list(Polygons(list(Polygon(meuse.riv)), "meuse.riv"))
meuse.sr <- SpatialPolygons(meuse.lst)
# grid for prediction
data(meuse.grid)
is(meuse.grid)
coordinates(meuse.grid) <- c('x','y')
meuse.grid <- as(meuse.grid, 'SpatialPixelsDataFrame')
# plot all together
image(meuse.grid, col = "lightgrey")
plot(meuse.sr, col = "grey", add = TRUE)
plot(meuse, add = TRUE)
title('meuse river geostatistical data')
# histogram of zinc variable
hist(meuse$zinc, breaks=16, col="grey", main='Histogram of Zn', prob = TRUE, xlab = 'Zn')
# highly skewed, transform to the log
hist(log(meuse$zinc), breaks=16, col="grey", main='Histogram of log(Zn)', prob = TRUE, xlab = 'log(Zn)')
# scatterplot of log(zinc) with respect to distance from the river
xyplot(log(zinc) ~ sqrt(dist), as.data.frame(meuse))
# Negative correlation: lower distance from the river => higher level of zinc
dev.off()
# sample variogram (binned estimator)
svgm <- variogram(log(zinc) ~ 1, meuse)
plot(svgm, main = 'Sample Variogram',pch=19)
# the following
plot(variogram(log(zinc) ~ 1, meuse),pch=19)
plot(variogram(log(zinc) ~ 1, meuse, alpha = c(0, 45, 90, 135)),pch=19)
plot(variogram(log(zinc) ~ 1, meuse, cutoff = 1000, width = 1000/15),pch=19)
# intervals can have different widths: to fix varying widths use the argument
# boudaries
plot(variogram(log(zinc) ~ 1, meuse, boundaries = c(0,200,seq(400,1500,100))),pch=19)
plot(variogram(log(zinc) ~ 1, meuse, cutoff = 1000, width = 1000/5),pch=19)
# list of parametric isotropic variogram models
vgm()
# some examples...
vgm(1, "Sph", 300)
vgm(1, "Sph", 300, 0.5)
# one can also add two or more models
v1 <- vgm(1, "Sph", 300, 0.5)
v2 <- vgm(0.8, "Sph", 800, add.to = v1)
v2
# this is only measurement error
vgm(0.5, "Nug", 0)
v <- variogram(log(zinc) ~ 1, meuse)
# some examples...
vgm(1, "Sph", 300)
vgm(1, "Sph", 300, 0.5)
# one can also add two or more models
v1 <- vgm(1, "Sph", 300, 0.5)
v2 <- vgm(0.8, "Sph", 800, add.to = v1)
v2
# this is only measurement error
vgm(0.5, "Nug", 0)
v <- variogram(log(zinc) ~ 1, meuse)
plot(v,pch=19)
# try reasonable initial values
fit.variogram(v, vgm(1, "Sph", 800, 1))
# try unreasonable initial values
fit.variogram(v, vgm(1, "Sph", 10, 1))
# try reasonable initial values
fit.variogram(v, vgm(1, "Sph", 800, 1))
# try unreasonable initial values
fit.variogram(v, vgm(1, "Sph", 10, 1))
v <- variogram(log(zinc) ~ 1, meuse)
plot(v,pch=19)
# try reasonable initial values
fit.variogram(v, vgm(1, "Sph", 800, 1))
# try unreasonable initial values
fit.variogram(v, vgm(1, "Sph", 10, 1))
# plot of the final fit
v <- variogram(log(zinc) ~ 1, meuse)
v.fit <- fit.variogram(v, vgm(1, "Sph", 800, 1))
plot(v, v.fit, pch = 19)
# fitting method: non linear regression with minimization of weighted
# sum of squares error. final value of the minimum
attr(v.fit, 'SSErr')
# ex: fix the nugget variance to the value 0.06
fit.variogram(v, vgm(1, "Sph", 800, 0.06), fit.sills = c(FALSE, TRUE))
fit.variogram.reml(log(zinc)~1, meuse, model=vgm(0.6, "Sph", 800, 0.06))
v.fit
## modeling anisotropy*
v.dir <- variogram(log(zinc)~1,meuse,alpha=(0:3)*45)
v.anis <- vgm(.6, "Sph", 1600, .05, anis=c(45, 0.3))
print(plot(v.dir, v.anis, pch=19))
## Prediction at a single new location
s0.new=data.frame(x=179180, y=330100) # UTM coordinates
coordinates(s0.new)=c('x','y')
# plot all together
image(meuse.grid, col = "lightgrey")
plot(meuse.sr, col = "grey", add = TRUE)
plot(meuse, add = TRUE)
plot(s0.new, add = TRUE, col='red', lwd = 2)
title('meuse river geostatistical data')
# Create a gstat object setting a spherical (residual) variogram
# gstat(g.obj, id, formula, data, model, set,...)
g.tr <- gstat(formula = log(zinc) ~ 1, data = meuse, model = v.fit)
## ordinary kriging
# Make the ordinary kriging prediction with the function:
# predict(obj, grid, BLUE=FALSE)
# this gives the prediction of Y(s_0):
predict(g.tr, s0.new)
# Estimate the mean:use the argument 'BLUE'
predict(g.tr, s0.new, BLUE = TRUE)
## consider a location where I OBSERVE data
# this gives the prediction of Y(s_0)
# in the first location (zero variance!)
meuse[1,]
predict(g.tr, meuse[1,])
# this gives the estimate of the mean
# (drift component) under gls
predict(g.tr, meuse[1,], BLUE = TRUE)
# prediction over the entire grid
lz.ok <- predict(g.tr, meuse.grid, BLUE = FALSE)
spplot(lz.ok)
# Create a gstat object setting a spherical (residual) variogram
# gstat(g.obj, id, formula, data, model, set,...)
meuse.gstat <- gstat(id = 'zinc', formula = log(zinc) ~ sqrt(dist),
data = meuse, nmax = 50, model=v.fit, set = list(gls=1))
meuse.gstat
meuse.gstat
# Estimate the variogram from GLS residuals:
?variogram.gstat
v.gls<-variogram(meuse.gstat)
plot(v.gls)
v.gls.fit <- fit.variogram(v.gls, vgm(1, "Sph", 1000, 1))
plot(v.gls, v.gls.fit, pch = 19)
# Update gstat object with variogram model
meuse.gstat <- gstat(id = 'zinc', formula = log(zinc) ~ sqrt(dist),
data = meuse, nmax = 50, model=v.gls.fit, set = list(gls=1))
## universal kriging:
## I have to define the covariate in s_0
s0.vec <- as.vector(slot(s0.new,'coords'))
v.gls.fit <- fit.variogram(v.gls, vgm(1, "Sph", 1000, 0.25))
plot(v.gls, v.gls.fit, pch = 19)
# Update gstat object with variogram model
meuse.gstat <- gstat(id = 'zinc', formula = log(zinc) ~ sqrt(dist),
data = meuse, nmax = 50, model=v.gls.fit, set = list(gls=1))
## universal kriging:
## I have to define the covariate in s_0
s0.vec <- as.vector(slot(s0.new,'coords'))
# distance to the river: calculate the distance between s0 and each point of
# the river, then select the minimum
s0.dist <- min(rowSums(scale(meuse.riv,s0.vec)^2))
s0.new <- as.data.frame(c(s0.new,s0.dist))
names(s0.new) <- c('x','y','dist')
coordinates(s0.new) <- c('x','y')
s0.new <- as(s0.new, 'SpatialPointsDataFrame')
s0.new
plot(v.gls, v.gls.fit, pch = 19)
v.gls.fit <- fit.variogram(v.gls, vgm(1, "Sph", 1000, 1))
plot(v.gls, v.gls.fit, pch = 19)
# Update gstat object with variogram model
meuse.gstat <- gstat(id = 'zinc', formula = log(zinc) ~ sqrt(dist),
data = meuse, nmax = 50, model=v.gls.fit, set = list(gls=1))
## universal kriging:
## I have to define the covariate in s_0
s0.vec <- as.vector(slot(s0.new,'coords'))
# distance to the river: calculate the distance between s0 and each point of
# the river, then select the minimum
s0.dist <- min(rowSums(scale(meuse.riv,s0.vec)^2))
s0.new <- as.data.frame(c(s0.new,s0.dist))
names(s0.new) <- c('x','y','dist')
coordinates(s0.new) <- c('x','y')
s0.new <- as(s0.new, 'SpatialPointsDataFrame')
s0.new
# Function "predict" uses the residual variogram stored in the gstat
# object to make the prediction
predict(meuse.gstat, s0.new)
# this gives the estimate of x(s_0)'*beta
# (trend component) under gls
predict(meuse.gstat, s0.new, BLUE = TRUE)
# prediction over the entire grid
lz.uk <- predict(meuse.gstat, meuse.grid, BLUE=FALSE)
# estimate of the mean over the entire grid
lz.uk.BLUE <- predict(meuse.gstat, meuse.grid, BLUE=TRUE)
spplot(lz.ok[,1], main = 'Ordinary Kriging, gstat')
spplot(lz.uk[,1], main = 'Universal Kriging, gstat')
spplot(lz.uk.BLUE[,1], main = 'Universal Kriging - drift , gstat')
View(s0.new)
View(meuse)
